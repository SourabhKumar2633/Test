<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Privacy Protocols Taxonomy</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            padding: 20px;
            animation: backgroundShift 20s ease-in-out infinite;
        }

        @keyframes backgroundShift {
            0%, 100% { background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%); }
            50% { background: linear-gradient(135deg, #f093fb 0%, #f5576c 50%, #4facfe 100%); }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 25px;
            padding: 30px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shimmer 3s infinite;
            pointer-events: none;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            z-index: 10;
        }

        .title {
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 700;
            margin-bottom: 10px;
            line-height: 1.2;
        }

        .subtitle {
            color: #7f8c8d;
            font-size: clamp(1rem, 2vw, 1.2rem);
            font-style: italic;
        }

        .graph-container {
            width: 100%;
            height: 80vh;
            min-height: 600px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 10;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 25px 0;
            flex-wrap: wrap;
            position: relative;
            z-index: 10;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .btn:hover::before {
            left: 100%;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            position: relative;
            z-index: 10;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #2c3e50;
            background: rgba(255, 255, 255, 0.7);
            padding: 8px 12px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid;
            flex-shrink: 0;
        }

        .tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(44, 62, 80, 0.95));
            color: white;
            padding: 16px 20px;
            border-radius: 12px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            backdrop-filter: blur(10px);
            max-width: 400px;
            line-height: 1.5;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Node and link styles */
        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node circle {
            transition: all 0.3s ease;
            stroke-width: 2px;
        }

        .node text {
            font-family: inherit;
            font-size: 13px;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .node:hover circle {
            stroke-width: 4px;
            filter: drop-shadow(0 0 12px rgba(0, 0, 0, 0.4));
        }

        .node:hover text {
            font-weight: bold;
            font-size: 15px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
        }

        .link {
            fill: none;
            stroke-width: 2px;
            transition: all 0.3s ease;
        }

        .link:hover {
            stroke-width: 4px;
            filter: drop-shadow(0 0 6px rgba(0, 0, 0, 0.3));
        }

        .context-note {
            font-size: 11px;
            fill: #666;
            font-style: italic;
        }

        /* GitHub Pages compatibility */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 20px;
            }
            
            .graph-container {
                height: 70vh;
                min-height: 500px;
            }
            
            .controls {
                gap: 10px;
            }
            
            .btn {
                padding: 10px 18px;
                font-size: 13px;
            }
            
            .legend {
                gap: 15px;
            }
            
            .legend-item {
                font-size: 12px;
                padding: 6px 10px;
            }
        }

        /* Loading animation */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            font-size: 18px;
            color: #7f8c8d;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e3e3e3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">Privacy Protocols Taxonomy</h1>
            <p class="subtitle">Interactive vs Non-Interactive Protocol Classification</p>
        </div>
        
        <div class="controls">
            <button class="btn" onclick="expandAll()">üîç Expand All</button>
            <button class="btn" onclick="collapseAll()">üìÅ Collapse All</button>
            <button class="btn" onclick="resetView()">üîÑ Reset View</button>
            <button class="btn" onclick="downloadSVG()">üíæ Download SVG</button>
        </div>
        
        <div class="graph-container" id="graph-container">
            <div class="loading">
                <div class="spinner"></div>
                Loading interactive graph...
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-circle" style="background: linear-gradient(135deg, #ff6b6b, #e74c3c); border-color: #c0392b;"></div>
                <span>Root Concept</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: linear-gradient(135deg, #feca57, #f39c12); border-color: #e67e22;"></div>
                <span>Interactive Protocols</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: linear-gradient(135deg, #a29bfe, #9b59b6); border-color: #8e44ad;"></div>
                <span>Non-Interactive Protocols</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: linear-gradient(135deg, #f9ca24, #f1c40f); border-color: #f39c12;"></div>
                <span>Interactive Methods</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: linear-gradient(135deg, #74b9ff, #3498db); border-color: #2980b9;"></div>
                <span>Non-Interactive Methods</span>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Privacy protocols data structure
        const privacyData = {
            name: "Privacy",
            children: [
                {
                    name: "Interactive Protocols",
                    children: [
                        { name: "Identity Mixers", note: "" },
                        { name: "Anonymous Credentials", note: "issuance phase" },
                        { name: "Mixnets", note: "" },
                        { name: "CoinJoin + CoinShuffle", note: "" },
                        { name: "Blind Signatures", note: "signing is interactive" },
                        { name: "Secure Multiparty Computation - SMC", note: "" },
                        { name: "Stealth Transactions", note: "setup/negotiation" }
                    ]
                },
                {
                    name: "Non-Interactive Protocols",
                    children: [
                        { name: "Credentials", note: "" },
                        { name: "Identity", note: "" },
                        { name: "Claims", note: "" },
                        { name: "PKI", note: "" },
                        { name: "Private Key Infrastructure", note: "" },
                        { name: "Digital Signature", note: "" },
                        { name: "Group Signatures", note: "" },
                        { name: "Ring Signatures", note: "" },
                        { name: "ZK-SNARKs", note: "" },
                        { name: "ZK-STARKs", note: "" },
                        { name: "ZK-Rollups", note: "" },
                        { name: "Bulletproofs", note: "" },
                        { name: "BOLT", note: "non-interactive once setup" },
                        { name: "PGP", note: "" },
                        { name: "PRF", note: "" },
                        { name: "HMAC, KDF", note: "" },
                        { name: "OPRF", note: "hybrid but usually non-interactive" },
                        { name: "Homomorphic Encryption", note: "" },
                        { name: "PKE, FHE", note: "" }
                    ]
                }
            ]
        };

        // Detailed descriptions for tooltips
        const descriptions = {
            "Privacy": "The fundamental concept of protecting personal information, communications, and digital activities through various cryptographic and technical protocols. It encompasses both hiding identity (anonymity) and protecting content (confidentiality).",
            
            "Interactive Protocols": "Privacy methods requiring real-time communication, coordination, or negotiation between multiple parties. These protocols typically involve multiple rounds of message exchange to achieve privacy goals.",
            
            "Non-Interactive Protocols": "Privacy methods that can function without ongoing communication between parties once initially established. These protocols allow privacy-preserving operations with minimal or no interaction.",

            // Interactive Protocols
            "Identity Mixers": "Advanced cryptographic systems that enable anonymous authentication by allowing users to prove possession of credentials without revealing their identity. They use sophisticated mixing techniques to break linkability between different authentications.",
            
            "Anonymous Credentials": "Digital certificates that allow users to prove certain attributes (age, membership, etc.) without revealing their identity. The issuance phase requires interaction between the credential issuer and holder to establish the cryptographic relationship.",
            
            "Mixnets": "Networks that provide strong anonymity by routing messages through multiple intermediate nodes (mixes) that shuffle, delay, and re-encrypt messages. Each mix removes one layer of encryption, making traffic analysis extremely difficult.",
            
            "CoinJoin + CoinShuffle": "Bitcoin privacy protocols that allow multiple users to combine their transactions into a single large transaction, making it difficult to determine which inputs correspond to which outputs. Requires coordination among participants.",
            
            "Blind Signatures": "Cryptographic primitive where a signer signs a message without seeing its content. The signing process is interactive - the message is 'blinded' before signing and 'unblinded' after, ensuring the signer cannot link the signature to the original interaction.",
            
            "Secure Multiparty Computation - SMC": "Protocols enabling multiple parties to jointly compute functions over their private inputs without revealing those inputs to each other. Requires extensive interaction and communication between all participants throughout the computation.",
            
            "Stealth Transactions": "Privacy-preserving payment methods where the recipient's address is hidden from public view. The setup and negotiation phase requires interaction between sender and receiver to establish shared secrets for address generation.",

            // Non-Interactive Protocols
            "Credentials": "Digital certificates or tokens that attest to certain attributes or permissions. Once issued, they can typically be verified without requiring interaction with the issuing authority.",
            
            "Identity": "Digital representations of entities (users, devices, organizations) that can be verified and authenticated through cryptographic means without requiring constant interaction with identity providers.",
            
            "Claims": "Assertions about entities or their attributes that can be cryptographically verified. Once established, claims can be validated independently without contacting the original asserting party.",
            
            "PKI": "Public Key Infrastructure - a framework for managing digital certificates and public-key encryption. Once established, enables secure communication and authentication without requiring interactive key exchange for each operation.",
            
            "Private Key Infrastructure": "Systems for securely generating, storing, and managing private cryptographic keys. Once properly established, allows for non-interactive signing and decryption operations.",
            
            "Digital Signature": "Cryptographic mechanism that ensures authenticity and integrity of digital messages. Once a message is signed, the signature can be verified by anyone with the public key without interaction with the signer.",
            
            "Group Signatures": "Allow members of a group to sign messages on behalf of the group without revealing which specific member created the signature. Verification requires no interaction with the signer or group manager.",
            
            "Ring Signatures": "Signatures that prove the signer belongs to a specific group (ring) of possible signers without revealing which member actually signed. Provides anonymity within the group without requiring interaction.",
            
            "ZK-SNARKs": "Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge - cryptographic proofs that allow verification of computational statements without revealing the underlying data. 'Non-interactive' means proofs can be verified without communication with the prover.",
            
            "ZK-STARKs": "Zero-Knowledge Scalable Transparent Arguments of Knowledge - similar to SNARKs but with better scalability, transparency (no trusted setup), and quantum resistance. Verification is completely non-interactive.",
            
            "ZK-Rollups": "Layer-2 blockchain scaling solutions that bundle multiple transactions and generate a zero-knowledge proof of their validity. Once the proof is generated, it can be verified on-chain without interaction with transaction originators.",
            
            "Bulletproofs": "Short non-interactive zero-knowledge proofs that don't require a trusted setup. They're particularly efficient for proving that committed values lie within a specific range, commonly used in confidential transactions.",
            
            "BOLT": "Blind Off-chain Lightweight Transactions - a protocol for anonymous payments that becomes non-interactive once the initial channel setup is complete. Subsequent payments can be made without ongoing coordination.",
            
            "PGP": "Pretty Good Privacy - an encryption program providing cryptographic privacy and authentication. Once keys are exchanged, encryption and decryption operations are non-interactive.",
            
            "PRF": "Pseudorandom Functions - cryptographic functions that appear random but are deterministic. Once established with a shared key, they can generate pseudorandom outputs non-interactively.",
            
            "HMAC, KDF": "Hash-based Message Authentication Code and Key Derivation Functions - cryptographic primitives for message authentication and key generation. Once keys are established, these operations are entirely non-interactive.",
            
            "OPRF": "Oblivious Pseudorandom Functions - allow one party to learn the output of a pseudorandom function on their input without the other party learning the input. While setup may be interactive, evaluation is typically non-interactive.",
            
            "Homomorphic Encryption": "Encryption schemes that allow computations to be performed on encrypted data without first decrypting it. Once data is encrypted, computations can be performed non-interactively, producing encrypted results.",
            
            "PKE, FHE": "Public Key Encryption and Fully Homomorphic Encryption - advanced encryption schemes. PKE enables secure communication without prior key exchange, while FHE allows arbitrary computations on encrypted data, both operating non-interactively."
        };

        // Graph dimensions and setup
        let width, height;
        let svg, g, tree, root, tooltip;
        let i = 0;
        const duration = 750;

        function initGraph() {
            // Remove loading indicator
            document.querySelector('.loading').remove();
            
            // Set dimensions based on container
            const container = d3.select("#graph-container");
            const containerRect = container.node().getBoundingClientRect();
            
            width = containerRect.width - 40;
            height = containerRect.height - 40;
            
            const margin = { top: 40, right: 120, bottom: 40, left: 120 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            // Create SVG
            svg = container
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .style("background", "linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%)")
                .style("border-radius", "15px");

            // Add gradient definitions
            const defs = svg.append("defs");

            // Define gradients
            const gradients = [
                { id: "rootGradient", stops: [{ offset: "0%", color: "#ff6b6b" }, { offset: "100%", color: "#e74c3c" }] },
                { id: "interactiveGradient", stops: [{ offset: "0%", color: "#feca57" }, { offset: "100%", color: "#f39c12" }] },
                { id: "nonInteractiveGradient", stops: [{ offset: "0%", color: "#a29bfe" }, { offset: "100%", color: "#9b59b6" }] },
                { id: "interactiveLeafGradient", stops: [{ offset: "0%", color: "#f9ca24" }, { offset: "100%", color: "#f1c40f" }] },
                { id: "nonInteractiveLeafGradient", stops: [{ offset: "0%", color: "#74b9ff" }, { offset: "100%", color: "#3498db" }] }
            ];

            gradients.forEach(grad => {
                const gradient = defs.append("radialGradient").attr("id", grad.id);
                grad.stops.forEach(stop => {
                    gradient.append("stop")
                        .attr("offset", stop.offset)
                        .attr("stop-color", stop.color);
                });
            });

            g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create tree layout
            tree = d3.tree().size([innerHeight, innerWidth]);

            // Create hierarchy
            root = d3.hierarchy(privacyData);
            root.x0 = innerHeight / 2;
            root.y0 = 0;

            // Collapse all children initially except first level
            root.children.forEach(collapse);

            // Setup tooltip
            tooltip = d3.select("#tooltip");

            // Initial render
            update(root);

            // Expand first level after a delay
            setTimeout(() => {
                if (root._children) {
                    root.children = root._children;
                    root._children = null;
                }
                update(root);
            }, 500);
        }

        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null;
            }
        }

        function update(source) {
            const treeData = tree(root);
            const nodes = treeData.descendants();
            const links = treeData.descendants().slice(1);

            // Normalize for fixed-depth
            nodes.forEach(d => d.y = d.depth * (width < 768 ? 180 : 220));

            // Update nodes
            const node = g.selectAll('g.node')
                .data(nodes, d => d.id || (d.id = ++i));

            // Enter new nodes
            const nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${source.y0},${source.x0})`)
                .on('click', click)
                .on('mouseover', function(event, d) {
                    showTooltip(event, d);
                })
                .on('mouseout', function() {
                    hideTooltip();
                });

            // Add circles
            nodeEnter.append('circle')
                .attr('r', 1e-6)
                .style('fill', getNodeFill)
                .style('stroke', getNodeStroke)
                .style('stroke-width', '2px')
                .style('filter', getNodeFilter);

            // Add main text
            nodeEnter.append('text')
                .attr('dy', '.35em')
                .attr('x', d => d.children || d._children ? -13 : 13)
                .attr('text-anchor', d => d.children || d._children ? 'end' : 'start')
                .text(d => d.data.name)
                .style('fill-opacity', 1e-6);

            // Add context notes for leaf nodes
            nodeEnter.filter(d => d.data.note && d.data.note.trim())
                .append('text')
                .attr('class', 'context-note')
                .attr('dy', '1.5em')
                .attr('x', d => d.children || d._children ? -13 : 13)
                .attr('text-anchor', d => d.children || d._children ? 'end' : 'start')
                .text(d => `[${d.data.note}]`)
                .style('fill-opacity', 1e-6);

            // Transition nodes to their new position
            const nodeUpdate = nodeEnter.merge(node);

            nodeUpdate.transition()
                .duration(duration)
                .attr('transform', d => `translate(${d.y},${d.x})`);

            nodeUpdate.select('circle')
                .transition()
                .duration(duration)
                .attr('r', d => {
                    if (d.depth === 0) return 12;
                    if (d.depth === 1) return 10;
                    return 7;
                });

            nodeUpdate.select('text')
                .transition()
                .duration(duration)
                .style('fill-opacity', 1);

            nodeUpdate.select('.context-note')
                .transition()
                .duration(duration)
                .style('fill-opacity', 0.7);

            // Remove exiting nodes
            const nodeExit = node.exit().transition()
                .duration(duration)
                .attr('transform', d => `translate(${source.y},${source.x})`)
                .remove();

            nodeExit.select('circle').attr('r', 1e-6);
            nodeExit.selectAll('text').style('fill-opacity', 1e-6);

            // Update links
            const link = g.selectAll('path.link')
                .data(links, d => d.id);

            const linkEnter = link.enter().insert('path', 'g')
                .attr('class', 'link')
                .attr('d', d => {
                    const o = { x: source.x0, y: source.y0 };
                    return diagonal(o, o);
                })
                .style('stroke', getLinkStroke)
                .style('stroke-width', '2px');

            const linkUpdate = linkEnter.merge(link);

            linkUpdate.transition()
                .duration(duration)
                .attr('d', d => diagonal(d, d.parent));

            link.exit().transition()
                .duration(duration)
                .attr('d', d => {
                    const o = { x: source.x, y: source.y };
                    return diagonal(o, o);
                })
                .remove();

            // Store old positions for transition
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }

        function getNodeFill(d) {
            if (d.depth === 0) return 'url(#rootGradient)';
            if (d.depth === 1) {
                return d.data.name === 'Interactive Protocols' ? 'url(#interactiveGradient)' : 'url(#nonInteractiveGradient)';
            }
            return d.parent.data.name === 'Interactive Protocols' ? 'url(#interactiveLeafGradient)' : 'url(#nonInteractiveLeafGradient)';
        }

        function getNodeStroke(d) {
            if (d.depth === 0) return '#c0392b';
            if (d.depth === 1) {
                return d.data.name === 'Interactive Protocols' ? '#e67e22' : '#8e44ad';
            }
            return d.parent.data.name === 'Interactive Protocols' ? '#f39c12' : '#2980b9';
        }

        function getNodeFilter(d) {
            const colors = {
                0: 'rgba(231, 76, 60, 0.3)',
                'Interactive Protocols': 'rgba(243, 156, 18, 0.3)',
                'Non-Interactive Protocols': 'rgba(155, 89, 182, 0.3)',
                'interactive-leaf': 'rgba(241, 196, 15, 0.3)',
                'non-interactive-leaf': 'rgba(52, 152, 219, 0.3)'
            };
            
            let colorKey;
            if (d.depth === 0) colorKey = 0;
            else if (d.depth === 1) colorKey = d.data.name;
            else colorKey = d.parent.data.name === 'Interactive Protocols' ? 'interactive-leaf' : 'non-interactive-leaf';
            
            return `drop-shadow(0 2px 6px ${colors[colorKey] || colors[0]})`;
        }

        function getLinkStroke(d) {
            if (d.parent && d.parent.depth === 0) {
                return d.data.name === 'Interactive Protocols' ? '#f39c12' : '#9b59b6';
            }
            if (d.parent && d.parent.data.name === 'Interactive Protocols') return '#f39c12';
            if (d.parent && d.parent.data.name === 'Non-Interactive Protocols') return '#9b59b6';
            return '#e74c3c';
        }

        function diagonal(s, d) {
            return `M ${s.y} ${s.x}
                    C ${(s.y + d.y) / 2} ${s.x},
                      ${(s.y + d.y) / 2} ${d.x},
                      ${d.y} ${d.x}`;
        }

        function click(event, d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update(d);
        }

        function showTooltip(event, d) {
            let description = descriptions[d.data.name] || `Privacy protocol: ${d.data.name}`;
            if (d.data.note && d.data.note.trim()) {
                description += ` <br><br><em><strong>Note:</strong> ${d.data.note}</em>`;
            }
            
            tooltip
                .style("opacity", 1)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 10) + "px")
                .html(description);
        }

        function hideTooltip() {
            tooltip.style("opacity", 0);
        }

        // Control functions
        function expandAll() {
            function expand(d) {
                if (d._children) {
                    d.children = d._children;
                    d._children = null;
                }
                if (d.children) d.children.forEach(expand);
            }
            expand(root);
            update(root);
        }

        function collapseAll() {
            function collapse(d) {
                if (d.children) {
                    d._children = d.children;
                    d._children.forEach(collapse);
                    d.children = null;
                }
            }
            root.children.forEach(collapse);
            update(root);
        }

        function resetView() {
            collapseAll();
            setTimeout(() => {
                if (root._children) {
                    root.children = root._children;
                    root._children = null;
                }
                update(root);
            }, 300);
        }

        function downloadSVG() {
            const svgElement = document.querySelector('#graph-container svg');
            const svgData = new XMLSerializer().serializeToString(svgElement);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const svgUrl = URL.createObjectURL(svgBlob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = svgUrl;
            downloadLink.download = 'privacy-protocols-taxonomy.svg';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(svgUrl);
        }

        // Responsive handling
        function handleResize() {
            const container = d3.select("#graph-container");
            const containerRect = container.node().getBoundingClientRect();
            
            const newWidth = containerRect.width - 40;
            const newHeight = containerRect.height - 40;
            
            if (Math.abs(newWidth - width) > 50 || Math.abs(newHeight - height) > 50) {
                width = newWidth;
                height = newHeight;
                
                svg.attr("width", width).attr("height", height);
                
                const margin = { top: 40, right: 120, bottom: 40, left: 120 };
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;
                
                tree.size([innerHeight, innerWidth]);
                update(root);
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initGraph();
            
            // Add resize listener
            window.addEventListener('resize', debounce(handleResize, 250));
        });

        // Utility function for debouncing
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey || event.metaKey) {
                switch(event.key) {
                    case 'e':
                        event.preventDefault();
                        expandAll();
                        break;
                    case 'c':
                        event.preventDefault();
                        collapseAll();
                        break;
                    case 'r':
                        event.preventDefault();
                        resetView();
                        break;
                    case 's':
                        event.preventDefault();
                        downloadSVG();
                        break;
                }
            }
        });

        // Add touch support for mobile
        let touchStartTime;
        document.addEventListener('touchstart', function(e) {
            touchStartTime = Date.now();
        });

        document.addEventListener('touchend', function(e) {
            const touchEndTime = Date.now();
            const touchDuration = touchEndTime - touchStartTime;
            
            // Long press (> 500ms) on mobile shows tooltip
            if (touchDuration > 500 && e.target.closest('.node')) {
                const node = e.target.closest('.node');
                const d = d3.select(node).datum();
                if (d) {
                    showTooltip({
                        pageX: e.changedTouches[0].pageX,
                        pageY: e.changedTouches[0].pageY
                    }, d);
                    
                    // Hide tooltip after 3 seconds
                    setTimeout(hideTooltip, 3000);
                }
            }
        });

        // Performance optimization: Only update visible elements
        function isElementVisible(element) {
            const rect = element.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        // Add loading states for better UX
        function showLoading() {
            const container = document.getElementById('graph-container');
            container.style.opacity = '0.5';
        }

        function hideLoading() {
            const container = document.getElementById('graph-container');
            container.style.opacity = '1';
        }

        // Enhanced error handling
        window.addEventListener('error', function(e) {
            console.error('Privacy Graph Error:', e.error);
            
            const container = document.getElementById('graph-container');
            if (container && !container.querySelector('svg')) {
                container.innerHTML = `
                    <div style="display: flex; justify-content: center; align-items: center; height: 100%; flex-direction: column; color: #7f8c8d;">
                        <h3>‚ö†Ô∏è Error Loading Graph</h3>
                        <p>Please refresh the page to try again.</p>
                        <button class="btn" onclick="location.reload()" style="margin-top: 15px;">üîÑ Refresh Page</button>
                    </div>
                `;
            }
        });

        // Add analytics-friendly events (optional)
        function trackInteraction(action, label) {
            // Add your analytics tracking here if needed
            console.log(`Graph Interaction: ${action} - ${label}`);
        }
    </script>
</body>
</html>
