<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Privacy Taxonomy Graph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #667eea 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding: 20px;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        .sidebar.collapsed {
            transform: translateX(-310px);
        }

        .sidebar-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sidebar-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .main-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .header {
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 300;
            margin-bottom: 5px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .header p {
            opacity: 0.8;
            font-size: 0.9rem;
        }

        .search-container {
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            text-align: center;
            font-size: 13px;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .control-btn.active {
            background: rgba(78, 205, 196, 0.3);
            border-color: rgba(78, 205, 196, 0.5);
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info-panel h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .info-panel p {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.5;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.8);
        }

        #graph {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #graph:active {
            cursor: grabbing;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            fill: #4a90e2;
            stroke: #ffffff;
            stroke-width: 2px;
            transition: all 0.3s ease;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        .node.root circle {
            fill: #ff6b6b;
            stroke-width: 3px;
        }

        .node.main circle {
            fill: #4ecdc4;
        }

        .node.technique circle {
            fill: #45b7d1;
        }

        .node.selected circle {
            stroke: #ffd700;
            stroke-width: 4px;
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.6));
        }

        .node.highlighted circle {
            fill: #ff9800;
            stroke: #fff;
            stroke-width: 3px;
        }

        .node.dimmed {
            opacity: 0.3;
        }

        .node text {
            fill: white;
            font-size: 11px;
            font-weight: 500;
            text-anchor: middle;
            dominant-baseline: middle;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            transition: all 0.3s ease;
        }

        .node.root text {
            font-size: 14px;
            font-weight: 700;
        }

        .node.main text {
            font-size: 12px;
            font-weight: 600;
        }

        .link {
            fill: none;
            stroke: rgba(255, 255, 255, 0.4);
            stroke-width: 2;
            stroke-linecap: round;
            transition: all 0.3s ease;
            marker-end: url(#arrowhead);
        }

        .link.highlighted {
            stroke: rgba(255, 215, 0, 0.8);
            stroke-width: 3;
            marker-end: url(#arrowhead-highlighted);
        }

        .link.dimmed {
            opacity: 0.1;
        }

        /* Arrow styles */
        .arrowhead {
            fill: rgba(255, 255, 255, 0.6);
            transition: all 0.3s ease;
        }

        .arrowhead-highlighted {
            fill: rgba(255, 215, 0, 0.8);
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(15px);
            max-width: 350px;
            line-height: 1.4;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.6);
            z-index: 1000;
        }

        .tooltip h4 {
            margin: 0 0 8px 0;
            color: #4ecdc4;
            font-size: 15px;
            font-weight: 600;
        }

        .tooltip p {
            margin: 0;
            color: #e0e0e0;
        }

        .breadcrumb {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 20px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
        }

        .breadcrumb-active {
            color: #4ecdc4;
            font-weight: 600;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .node.pulsing circle {
            animation: pulse 1s infinite;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .legend-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid white;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <button class="sidebar-toggle" onclick="toggleSidebar()">‚ò∞</button>
        
        <div class="sidebar" id="sidebar">
            <div class="header">
                <h1>Privacy Taxonomy</h1>
                <p>Interactive Knowledge Graph</p>
            </div>

            <div class="search-container">
                <input type="text" class="search-input" placeholder="Search techniques..." id="searchInput" oninput="searchNodes()">
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div class="stat-number" id="nodeCount">29</div>
                    <div class="stat-label">Techniques</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="visibleCount">3</div>
                    <div class="stat-label">Visible</div>
                </div>
            </div>

            <div class="controls">
                <button class="control-btn" onclick="centerGraph()">üéØ Center View</button>
                <button class="control-btn" onclick="toggleLayout()" id="layoutBtn">üåê Network Layout</button>
                <button class="control-btn" onclick="expandAll()">üìñ Expand All</button>
                <button class="control-btn" onclick="collapseAll()">üìö Collapse All</button>
                <button class="control-btn" onclick="resetSelection()">‚ú® Clear Selection</button>
            </div>

            <div class="breadcrumb" id="breadcrumb">
                <span class="breadcrumb-active">Privacy</span>
            </div>

            <div class="info-panel" id="infoPanel">
                <h3>Welcome to Privacy Taxonomy!</h3>
                <p><strong>Instructions:</strong></p>
                <p>‚Ä¢ Click nodes to explore and expand/collapse</p>
                <p>‚Ä¢ Hover for detailed descriptions</p>
                <p>‚Ä¢ Use search to find specific techniques</p>
                <p>‚Ä¢ Toggle between tree and network layouts</p>
                <p>‚Ä¢ Arrows show parent ‚Üí child relationships</p>
            </div>
        </div>

        <div class="main-content">
            <div id="graph"></div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-circle" style="background: #ff6b6b;"></div>
                    <span>Root (Privacy)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #4ecdc4;"></div>
                    <span>Categories</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #45b7d1;"></div>
                    <span>Techniques</span>
                </div>
            </div>

            <div class="instructions">
                üí° Hover over nodes for details ‚Ä¢ Click to expand/collapse ‚Ä¢ Double-click to focus ‚Ä¢ Arrows show hierarchy
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        const privacyData = {
            name: "Privacy",
            id: "privacy",
            description: "The overarching concept of controlling personal information disclosure and protecting user data from unauthorized access.",
            category: "root",
            children: [
                {
                    name: "Anonymity",
                    id: "anonymity", 
                    description: "Techniques that focus on hiding identity and creating unlinkability between actions and users.",
                    category: "main",
                    children: [
                        { 
                            name: "Identity", id: "identity",
                            description: "The fundamental concept of who someone is in digital systems. Protects real-world identities from being linked to digital activities.",
                            category: "technique"
                        },
                        { 
                            name: "Claims", id: "claims",
                            description: "Assertions about identity or attributes that can be verified without revealing underlying personal information.",
                            category: "technique"
                        },
                        { 
                            name: "Anonymous Credentials", id: "anonymous_credentials",
                            description: "Cryptographic systems allowing users to prove possession of credentials without revealing identity or unrelated information.",
                            category: "technique"
                        },
                        { 
                            name: "Identity Mixers", id: "identity_mixers",
                            description: "Advanced protocols enabling anonymous authentication and selective attribute disclosure without linking transactions.",
                            category: "technique"
                        },
                        { 
                            name: "Mixnets", id: "mixnets",
                            description: "Multistage systems using cryptography to provide anonymity by routing messages through intermediate nodes.",
                            category: "technique"
                        },
                        { 
                            name: "Group Signatures", id: "group_signatures",
                            description: "Signature schemes enabling user anonymity within groups, with a group manager who can revoke anonymity when needed.",
                            category: "technique"
                        },
                        { 
                            name: "Ring Signatures", id: "ring_signatures",
                            description: "Digital signatures created by group members where it's impossible to determine which specific person created the signature.",
                            category: "technique"
                        },
                        { 
                            name: "CoinJoin + CoinShuffle", id: "coinjoin",
                            description: "Bitcoin mixing techniques combining multiple transactions to obscure connections between inputs and outputs.",
                            category: "technique"
                        },
                        { 
                            name: "Blind Signatures", id: "blind_signatures",
                            description: "Cryptographic signatures where the signer cannot see the content being signed, enabling anonymous digital cash.",
                            category: "technique"
                        },
                        { 
                            name: "Bulletproofs", id: "bulletproofs",
                            description: "Cryptographic proofs enabling range proofs without revealing actual values, useful for private cryptocurrency transactions.",
                            category: "technique"
                        },
                        { 
                            name: "BOLT", id: "bolt",
                            description: "Blind Off-chain Lightweight Transactions protocol for privacy-preserving payment channels and anonymous micropayments.",
                            category: "technique"
                        },
                        { 
                            name: "Monero, Zcash", id: "privacy_coins",
                            description: "Privacy-focused cryptocurrencies using ring signatures (Monero) and zk-SNARKs (Zcash) for transaction anonymity.",
                            category: "technique"
                        },
                        { 
                            name: "Stealth Transactions", id: "stealth",
                            description: "Transaction methods hiding recipient addresses on blockchain while allowing them to receive and spend funds.",
                            category: "technique"
                        }
                    ]
                },
                {
                    name: "Confidentiality",
                    id: "confidentiality",
                    description: "Methods ensuring data remains secret from unauthorized parties through encryption and secure computation.",
                    category: "main",
                    children: [
                        { 
                            name: "Credentials", id: "credentials",
                            description: "Digital certificates attesting to identity, attributes, or authorization while maintaining privacy when possible.",
                            category: "technique"
                        },
                        { 
                            name: "PKI", id: "pki",
                            description: "Public Key Infrastructure - framework managing digital certificates and public-key encryption for secure communications.",
                            category: "technique"
                        },
                        { 
                            name: "Private Key Infrastructure", id: "private_key_infrastructure",
                            description: "Systems focused on secure generation, storage, and management of private keys used for decryption and signing.",
                            category: "technique"
                        },
                        { 
                            name: "Digital Signature", id: "digital_signature",
                            description: "Cryptographic mechanisms providing authentication, non-repudiation, and integrity for digital messages.",
                            category: "technique"
                        },
                        { 
                            name: "Project", id: "project",
                            description: "Generic term referring to specific privacy projects or implementations within confidentiality frameworks.",
                            category: "technique"
                        },
                        { 
                            name: "ZK-SNARKs", id: "zk_snarks",
                            description: "Zero-Knowledge Succinct Non-Interactive Arguments - proofs validating claims without revealing private information.",
                            category: "technique"
                        },
                        { 
                            name: "ZK-STARKs", id: "zk_starks",
                            description: "Zero-Knowledge Scalable Transparent Arguments - more scalable than SNARKs and don't require trusted setup.",
                            category: "technique"
                        },
                        { 
                            name: "ZK-Rollups", id: "zk_rollups",
                            description: "Layer 2 blockchain scaling solutions using zero-knowledge proofs to bundle transactions while maintaining privacy.",
                            category: "technique"
                        },
                        { 
                            name: "PGP", id: "pgp",
                            description: "Pretty Good Privacy - encryption program providing cryptographic privacy and authentication for data communication.",
                            category: "technique"
                        },
                        { 
                            name: "PRF", id: "prf",
                            description: "Pseudorandom Function - cryptographic functions appearing random without the secret key but deterministic with it.",
                            category: "technique"
                        },
                        { 
                            name: "HMAC, KDF", id: "hmac_kdf",
                            description: "Hash-based Message Authentication Code and Key Derivation Function for message integrity and secure key generation.",
                            category: "technique"
                        },
                        { 
                            name: "OPRF", id: "oprf",
                            description: "Oblivious Pseudorandom Function - protocol allowing function evaluation without server learning client input.",
                            category: "technique"
                        },
                        { 
                            name: "Homomorphic Encryption", id: "homomorphic",
                            description: "Encryption allowing computations on encrypted data without decryption, enabling privacy-preserving computation.",
                            category: "technique"
                        },
                        { 
                            name: "PKE, FHE, SMC", id: "advanced_crypto",
                            description: "Public Key Encryption, Fully Homomorphic Encryption, and Secure Multi-party Computation methods.",
                            category: "technique"
                        }
                    ]
                }
            ]
        };

        // Graph setup
        let width = window.innerWidth - 350;
        let height = window.innerHeight;
        let isTreeLayout = true;
        let selectedNode = null;
        let nodeId = 0;

        const svg = d3.select("#graph")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Define arrow markers
        const defs = svg.append("defs");

        // Standard arrowhead
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 8)
            .attr("refY", 0)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .style("fill", "rgba(255, 255, 255, 0.6)")
            .style("stroke", "none");

        // Highlighted arrowhead
        defs.append("marker")
            .attr("id", "arrowhead-highlighted")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 8)
            .attr("refY", 0)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .style("fill", "rgba(255, 215, 0, 0.8)")
            .style("stroke", "none");

        const g = svg.append("g");

        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        svg.call(zoom);

        // Force simulation
        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.data.id).distance(80).strength(0.5))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(40));

        const tooltip = d3.select("#tooltip");
        const infoPanel = d3.select("#infoPanel");
        const breadcrumb = d3.select("#breadcrumb");

        let root = d3.hierarchy(privacyData);
        let nodes, links;

        function initializeGraph() {
            root.x0 = height / 2;
            root.y0 = width / 2;
            
            // Initially collapse children
            if (root.children) {
                root.children.forEach(d => {
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    }
                });
            }

            updateGraph();
        }

        function updateGraph() {
            if (isTreeLayout) {
                updateTreeLayout();
            } else {
                updateForceLayout();
            }
        }

        function updateTreeLayout() {
            const treemap = d3.tree().size([height - 100, width - 200]);
            const treeData = treemap(root);
            
            nodes = treeData.descendants();
            links = treeData.descendants().slice(1);

            updateNodes();
            updateLinks();
            updateStats();
            
            simulation.stop();
        }

        function updateForceLayout() {
            nodes = root.descendants();
            links = root.links();

            updateNodes();
            updateLinks();
            updateStats();

            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
        }

        function updateNodes() {
            const node = g.selectAll(".node")
                .data(nodes, d => d.data.id);

            node.exit()
                .transition()
                .duration(500)
                .style("opacity", 0)
                .remove();

            const nodeEnter = node.enter().append("g")
                .attr("class", d => `node ${d.data.category}`)
                .style("opacity", 0)
                .on("click", handleNodeClick)
                .on("dblclick", handleNodeDoubleClick)
                .on("mouseover", handleMouseOver)
                .on("mousemove", handleMouseMove)
                .on("mouseout", handleMouseOut);

            nodeEnter.append("circle")
                .attr("r", d => {
                    if (d.data.category === 'root') return 18;
                    if (d.data.category === 'main') return 14;
                    return 10;
                });

            nodeEnter.append("text")
                .attr("dy", d => d.children || d._children ? -25 : 25)
                .text(d => d.data.name.length > 15 ? d.data.name.substring(0, 12) + "..." : d.data.name);

            const nodeUpdate = nodeEnter.merge(node);

            nodeUpdate
                .transition()
                .duration(500)
                .style("opacity", 1)
                .attr("transform", d => {
                    if (isTreeLayout) {
                        return `translate(${d.y + 100},${d.x + 50})`;
                    }
                    return `translate(${d.x || width/2},${d.y || height/2})`;
                });

            if (!isTreeLayout) {
                nodeUpdate.call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

                simulation.on("tick", () => {
                    g.selectAll(".link")
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    g.selectAll(".node")
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                });
            }
        }

        function updateLinks() {
            const link = g.selectAll(".link")
                .data(links, d => d.target ? `${d.source.data.id}-${d.target.data.id}` : d.data.id);

            link.exit().remove();

            const linkEnter = link.enter()
                .insert("line", "g")
                .attr("class", "link")
                .style("opacity", 0);

            const linkUpdate = linkEnter.merge(link);

            linkUpdate
                .transition()
                .duration(500)
                .style("opacity", 1);

            if (isTreeLayout) {
                // For tree layout, use lines instead of paths for simplicity
                linkUpdate
                    .attr("x1", d => (d.parent ? d.parent.y + 100 : d.y + 100))
                    .attr("y1", d => (d.parent ? d.parent.x + 50 : d.x + 50))
                    .attr("x2", d => d.y + 100)
                    .attr("y2", d => d.x + 50);
            } else {
                linkUpdate
                    .attr("x1", d => d.source.x || width/2)
                    .attr("y1", d => d.source.y || height/2)
                    .attr("x2", d => d.target.x || width/2)
                    .attr("y2", d => d.target.y || height/2);
            }
        }

        function updateStats() {
            const visibleNodes = nodes.filter(d => d.depth <= 2);
            document.getElementById('visibleCount').textContent = visibleNodes.length;
        }

        // Event handlers
        function handleNodeClick(event, d) {
            event.stopPropagation();
            
            if (selectedNode) {
                selectedNode.classed("selected", false);
            }
            
            selectedNode = d3.select(this);
            selectedNode.classed("selected", true);
            
            updateInfoPanel(d);
            updateBreadcrumb(d);

            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else if (d._children) {
                d.children = d._children;
                d._children = null;
            }
            
            updateGraph();
        }

        function handleNodeDoubleClick(event, d) {
            event.stopPropagation();
            
            const [x, y] = isTreeLayout ? [d.y + 100, d.x + 50] : [d.x, d.y];
            const transform = d3.zoomIdentity
                .translate(width / 2 - x, height / 2 - y)
                .scale(1.5);
            
            svg.transition()
                .duration(750)
                .call(zoom.transform, transform);
        }

        function handleMouseOver(event, d) {
            tooltip
                .style("opacity", 1)
                .html(`<h4>${d.data.name}</h4><p>${d.data.description}</p>`);

            if (!isTreeLayout) {
                highlightConnections(d);
            }
        }

        function handleMouseMove(event) {
            tooltip
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 10) + "px");
        }

        function handleMouseOut(event, d) {
            tooltip.style("opacity", 0);
            
            if (!isTreeLayout) {
                clearHighlights();
            }
        }

        function highlightConnections(node) {
            g.selectAll(".node").classed("dimmed", true);
            g.selectAll(".link").classed("dimmed", true);
            
            g.selectAll(".node")
                .filter(d => d === node)
                .classed("highlighted dimmed", false);
                
            g.selectAll(".link")
                .filter(d => d.source === node || d.target === node)
                .classed("highlighted dimmed", false)
                .each(function(d) {
                    const connectedNode = d.source === node ? d.target : d.source;
                    g.selectAll(".node")
                        .filter(n => n === connectedNode)
                        .classed("highlighted dimmed", false);
                });
        }

        function clearHighlights() {
            g.selectAll(".node").classed("highlighted dimmed", false);
            g.selectAll(".link").classed("highlighted dimmed", false);
        }

        function updateInfoPanel(d) {
            infoPanel.html(`
                <h3>${d.data.name}</h3>
                <p><strong>Category:</strong> ${d.data.category}</p>
                <p><strong>Description:</strong> ${d.data.description}</p>
                ${d.children ? `<p><strong>Sub-techniques:</strong> ${d.children.length}</p>` : ''}
                ${d._children ? `<p><strong>Hidden sub-techniques:</strong> ${d._children.length}</p>` : ''}
            `);
        }

        function updateBreadcrumb(d) {
            const path = [];
            let current = d;
            
            while (current) {
                path.unshift(current.data.name);
                current = current.parent;
            }
            
            breadcrumb.html(
                path.map((name, i) => 
                    `<span class="${i === path.length - 1 ? 'breadcrumb-active' : ''}">${name}</span>`
                ).join(' ‚Üí ')
            );
        }

        // Drag functions for force layout
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Control functions
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
        }

        function centerGraph() {
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity);
        }

        function toggleLayout() {
            isTreeLayout = !isTreeLayout;
            const btn = document.getElementById('layoutBtn');
            btn.textContent = isTreeLayout ? 'üåê Network Layout' : 'üå≥ Tree Layout';
            btn.classList.toggle('active');
            updateGraph();
        }

        function expandAll() {
            function expand(d) {
                if (d._children) {
                    d.children = d._children;
                    d._children = null;
                }
                if (d.children) {
                    d.children.forEach(expand);
                }
            }
            expand(root);
            updateGraph();
        }

        function collapseAll() {
            function collapse(d) {
                if (d.children) {
                    d._children = d.children;
                    d._children.forEach(collapse);
                    d.children = null;
                }
            }
            if (root.children) {
                root.children.forEach(collapse);
            }
            updateGraph();
        }

        function resetSelection() {
            if (selectedNode) {
                selectedNode.classed("selected", false);
                selectedNode = null;
            }
            clearHighlights();
            
            infoPanel.html(`
                <h3>Welcome to Privacy Taxonomy!</h3>
                <p><strong>Instructions:</strong></p>
                <p>‚Ä¢ Click nodes to explore and expand/collapse</p>
                <p>‚Ä¢ Hover for detailed descriptions</p>
                <p>‚Ä¢ Use search to find specific techniques</p>
                <p>‚Ä¢ Toggle between tree and network layouts</p>
                <p>‚Ä¢ Arrows show parent ‚Üí child relationships</p>
            `);
            
            breadcrumb.html('<span class="breadcrumb-active">Privacy</span>');
        }

        function searchNodes() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            g.selectAll(".node")
                .classed("highlighted", d => {
                    const match = d.data.name.toLowerCase().includes(searchTerm) || 
                                 d.data.description.toLowerCase().includes(searchTerm);
                    return searchTerm && match;
                })
                .classed("dimmed", d => {
                    if (!searchTerm) return false;
                    const match = d.data.name.toLowerCase().includes(searchTerm) || 
                                 d.data.description.toLowerCase().includes(searchTerm);
                    return !match;
                });

            // Auto-expand nodes that match search
            if (searchTerm) {
                root.descendants().forEach(d => {
                    const match = d.data.name.toLowerCase().includes(searchTerm) || 
                                 d.data.description.toLowerCase().includes(searchTerm);
                    if (match && d.parent && d.parent._children) {
                        d.parent.children = d.parent._children;
                        d.parent._children = null;
                    }
                });
                updateGraph();
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            width = window.innerWidth - 350;
            height = window.innerHeight;
            
            svg.attr("width", width).attr("height", height);
            
            if (isTreeLayout) {
                updateGraph();
            } else {
                simulation.force("center", d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return; // Don't trigger when typing in search
            
            switch(e.key.toLowerCase()) {
                case 'c':
                    centerGraph();
                    break;
                case 't':
                    toggleLayout();
                    break;
                case 'e':
                    expandAll();
                    break;
                case 'r':
                    collapseAll();
                    break;
                case 'escape':
                    resetSelection();
                    break;
            }
        });

        // Initialize the graph
        initializeGraph();
        
        // Update initial stats
        document.getElementById('nodeCount').textContent = root.descendants().length;
        
        // Add some initial pulsing to root
        setTimeout(() => {
            g.select('.node.root').classed('pulsing', true);
            setTimeout(() => {
                g.select('.node.root').classed('pulsing', false);
            }, 3000);
        }, 1000);

        // Click outside to deselect
        svg.on("click", function(event) {
            if (event.target === this) {
                resetSelection();
            }
        });
    </script>
</body>
</html>
